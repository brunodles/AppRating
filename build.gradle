buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.jsoup:jsoup:1.11.3'
        classpath 'com.google.firebase:firebase-admin:5.9.0'
        classpath "io.reactivex.rxjava2:rxjava:2.1.16"
        classpath 'com.brunodles:alchemy-alchemist:2.0.0'
    }
}

String[][] developers = [
        ["Nubank", devId("Nubank")],
        ["Via Varejo", devId("Via+Varejo+S.A.")],
        ["Ita√∫", cpl("igM4ChkKEzY2NzAyMzI4NDMwODIzNDExOTkQCBgDEhkKEzY2NzAyMzI4NDMwODIzNDExOTkQCBgDGAA%3D:S:ANO1ljJcHU4")],
        ["Bradesco", devId("Banco+Bradesco+SA")],
        ["Santander", devId("Banco+Santander+%28Brasil%29+S.A.")],
        ["Inter", devId("Banco+Inter+SA")],
        ["Banco do Brasil", devId("Banco+do+Brasil+SA")],
        ["BV", devId("Banco+Votorantim+S/A")],
        ["B2W", devId("B2W+Digital")],
        ["Luiza Labs", cpl("igM4ChkKEzY5NjA2MTkyNjA3MzU5NjY2NzcQCBgDEhkKEzY5NjA2MTkyNjA3MzU5NjY2NzcQCBgDGAA%3D:S:ANO1ljIg2m0")],
        ["GPA", devId("GPA")],
        ["Caixa", devId("Caixa+Econ%C3%B4mica+Federal")],
        ["Carrefour", search("Carrefour"), devId("CarrefourSA"), devId("Carrefour")],
        ["CVC", devId("CVC+Brasil")],
        ["Wallmart", devId("Walmart.com")],
]

final String ENV_ROOT_REFERENCE = "FIREBASE_ROOT_REFERENCE"

task appRating {

    group "main"

    doLast {
        List<String> referencesList = new ArrayList<String>()
        if (System.getenv().containsKey(ENV_ROOT_REFERENCE))
            referencesList.add(System.getenv(ENV_ROOT_REFERENCE))
        referencesList.add("rattings")
        referencesList.removeAll { it == null || it.isEmpty() }
        String rootReferenceName = referencesList.join("-")

        def disposable = new RatingFetcher(developers, this.getClass().getClassLoader(),
                new DataBase(rootReferenceName))
                .appsMap()
                .subscribe(
                { println "Sent: " + it.name },
                { e -> e.printStackTrace() }
        )

        while (!disposable.isDisposed())
            Thread.sleep(5000)
    }
}

task assemble {
    doLast {
        println "Write credentials to a file"
        def credentials = new File(rootProject.projectDir, "google.json")
        credentials.write(System.getenv('FIREBASE_CONFIG'))
    }
}

task checkInternet {
    doLast {
        def connection = new URL("https://play.google.com/store/apps").openConnection()
        int response = connection.responseCode
        if (response != 200)
            throw new GradleScriptException("Error, can't check internet connection", null)
        println "Internet is available"
    }
}

task fixRatings {
    doLast {

        def base = new DataBase()
        base.reference.child("HEAD-ci-ratings/2018-08-07").addListenerForSingleValueEvent(new ValueEventListener() {
            @Override
            void onDataChange(DataSnapshot snapshot) {
                base.reference.child("ci-ratings/2018-08-06").setValue(snapshot.value)
            }

            @Override
            void onCancelled(DatabaseError error) {

            }
        })
    }
}

task listApps {
    doLast {

        final Set<String> done = new HashSet<>()

        def alchemist = new Alchemist.Builder()
                .classLoader(this.getClass().getClassLoader())
                .build()

        def appsReference = new DataBase("apps").reference

        def disposable = Observable.fromArray(developers)
                .subscribeOn(Schedulers.computation())
                .map { developer -> Arrays.copyOfRange(developer, 1, developer.length) }
                .flatMap(Observable.&fromArray)
                .flatMap {
            Observable.just(alchemist.parseUrl(it, Developer.class))
                    .subscribeOn(Schedulers.io())
                    .flatMap { Observable.fromIterable(it.apps()) }
                    .filter { App app -> !done.contains(app.detailsUrl()) }
                    .doOnNext { m -> done.add(m.detailsUrl()) }
        }.map { it.detailsUrl() }
                .map { it.replace("/store/apps/details?id=", "") }
                .doOnNext { appsReference.child(it.replaceAll(/[.#$\[\]]/, "-")).setValue(it) }
                .subscribe(
                { println it },
                { it.printStackTrace() }
        )


        while (!disposable.isDisposed())
            Thread.sleep(5000)
    }
}


static String devId(String id) {
    return "https://play.google.com/store/apps/developer?id=$id"
}

static String cpl(String id) {
    return "https://play.google.com/store/apps/collection/cluster?clp=$id"
}

static String search(String query) {
    return "https://play.google.com/store/search?c=apps&q=$query"
}


import com.brunodles.alchemist.Alchemist
import com.brunodles.alchemist.collectors.AttrCollector
import com.brunodles.alchemist.collectors.TextCollector
import com.brunodles.alchemist.nested.Nested
import com.brunodles.alchemist.selector.Selector
import com.brunodles.alchemist.usevalueof.UseValueOf
import com.google.api.core.ApiFuture
import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import com.google.firebase.database.*
import io.reactivex.Observable
import io.reactivex.schedulers.Schedulers

import java.text.SimpleDateFormat
import java.util.regex.Pattern

class DataBase {
    final DatabaseReference reference

    DataBase() {
        this(null)
    }

    DataBase(String rootReferenceName) {
        this.reference = buildRatingsReference(rootReferenceName)
    }

    private static DatabaseReference buildRatingsReference(String rootReferenceName) {
        InputStream serviceAccount = new FileInputStream("google.json")
        FirebaseOptions options = new FirebaseOptions.Builder()
                .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                .setDatabaseUrl("https://brunodles-apprating.firebaseio.com/")
                .build()

        def firebase = FirebaseApp.initializeApp(options, "Admin-" +
                String.valueOf(new Random().nextLong()))
        def reference = FirebaseDatabase.getInstance(firebase)
        if (rootReferenceName == null)
            return reference.getReference()
        return reference.getReference(rootReferenceName)
    }

    DatabaseReference child(String path) {
        return reference.child(path)
    }
}

@SuppressWarnings("GroovyUnusedDeclaration")
class RatingFetcher {

    static final idPattern = Pattern.compile(/\?id=(.*?)(?:&|$)/)

    private final String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date())
    private final Set<String> done = new HashSet<>()
    private final Alchemist alchemist
    private final String[][] developers
    private final DataBase dataBase

    RatingFetcher(String[][] developers, ClassLoader classLoader, DataBase dataBase) {
        this.developers = developers
        this.dataBase = dataBase
        alchemist = new Alchemist.Builder()
                .classLoader(classLoader)
                .build()
    }

    Observable<ApiFuture<Void>> appsMap() {
        return Observable.fromArray(developers)
                .subscribeOn(Schedulers.computation())
                .doOnNext { d -> println "Developer: ${d[0]}" }
                .map { developer -> Arrays.copyOfRange(developer, 1, developer.length) }
                .flatMap(Observable.&fromArray)
                .flatMap(this.&developerApps)
                .doOnNext { println "App: ${it.title()}" }
                .map(this.&mapToMap)
                .doOnNext { m -> dataBase.child("${date}/${m.appId}".replaceAll(/[.#$\[\]]/, "-")).setValueAsync(m) }
    }

    private Observable<App> developerApps(String url) {
        return Observable.just(url)
                .map { it -> alchemist.parseUrl(it, Developer.class) }
                .flatMap { Observable.fromIterable(it.apps()) }
                .filter { App app -> !done.contains(app.detailsUrl()) }
                .doOnNext { m -> done.add(m.detailsUrl()) }
                .subscribeOn(Schedulers.newThread())
    }

    private Map<String, Object> mapToMap(App app) {
        def map = new HashMap<String, Object>()
//        def appRef = reference.getReference("${date}/${empresa[0]}/${app.title()}")
        String appDetailsUrl = "https://play.google.com" + app.detailsUrl()

        map.put("name", app.title())
        map.put("coverImageUrl", "https" + app.converImage())
        map.put("url", appDetailsUrl)

        def matcher = idPattern.matcher(appDetailsUrl)
        if (!matcher.find())
            throw new RuntimeException("App id not found on \"${appDetailsUrl}\"")
        def group = matcher.group(1)
        if (group == null || group.isEmpty())
            throw new RuntimeException("App id not found on \"${appDetailsUrl}\"")
        map.put("appId", group)

        try {
            AppDetails appDetails = alchemist.parseUrl(appDetailsUrl, AppDetails.class)

            map.put("ratting", appDetails.rating())
            map.put("name", appDetails.name())
        } catch (Exception e) {
            new Exception("Failed to get details for \"${app.title()}\" using \"${appDetailsUrl}\".", e)
                    .printStackTrace()
        }
        return map
    }


}

interface Developer {
    @Selector(".card-content")
    @Nested
    ArrayList<App> apps()
}

interface App {
    @Selector(".cover-image")
    @AttrCollector("data-cover-large")
    String converImage();

    @Selector(".title")
    @AttrCollector("title")
    String title();

    @Selector(".card-click-target")
    @AttrCollector("href")
    String detailsUrl();
}

interface AppDetails {
    @Selector("[itemprop=\"name\"] span")
    @TextCollector
    String name()

    @Selector("meta[itemprop=\"ratingValue\"]")
    @AttrCollector("content")
    @UseValueOf
    Float rating()
}
