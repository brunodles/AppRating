buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.jsoup:jsoup:1.11.3'
        classpath 'com.google.firebase:firebase-admin:5.9.0'
        classpath "io.reactivex.rxjava2:rxjava:2.1.16"
        classpath 'com.brunodles:alchemy-alchemist:2.0.0'
    }
}

String[][] developers = [
        ["Nubank", devId("Nubank")],
        ["Via Varejo", devId("Via+Varejo+S.A.")],
        ["ItaÃº", cpl("igM4ChkKEzY2NzAyMzI4NDMwODIzNDExOTkQCBgDEhkKEzY2NzAyMzI4NDMwODIzNDExOTkQCBgDGAA%3D:S:ANO1ljJcHU4")],
        ["Bradesco", devId("Banco+Bradesco+SA")],
        ["Santander", devId("Banco+Santander+%28Brasil%29+S.A.")],
        ["Inter", devId("Banco+Inter+SA")],
//        ["Banco do Brasil", devId("Banco+do+Brasil+SA")],
//        ["BV", devId("Banco+Votorantim+S/A")],
//        ["B2W", devId("B2W+Digital")],
//        ["Luiza Labs", cpl("igM4ChkKEzY5NjA2MTkyNjA3MzU5NjY2NzcQCBgDEhkKEzY5NjA2MTkyNjA3MzU5NjY2NzcQCBgDGAA%3D:S:ANO1ljIg2m0")],
//        ["Carrefour", search("Carrefour"), devId("Carrefour+Brasil"), devId("Banco+CSF+SA"), devId("CarrefourSA"), devId("Carrefour")],
//        ["GPA", devId("GPA")],
//        ["Wallmart", devId("Walmart.com")],
//        ["Caixa", devId("Caixa+Econ%C3%B4mica+Federal")],
//        ["Track", search("banco"), search("varejo"), search("loja")]
]

task appRating {
    group "main"

    doLast {
        def disposable = new RatingFetcher(developers, this.getClass().getClassLoader())
                .appsMap()
                .subscribe(
                { r -> void },
                { e -> e.printStackTrace() }
        )

        while (!disposable.isDisposed())
            Thread.sleep(5000)
    }
}

task assemble {
    doLast {
        println "Write credentials to a file"
        def credentials = new File(rootProject.projectDir, "google.json")
        credentials.write(System.getenv('FIREBASE_CONFIG'))
    }
}

task checkInternet {
    doLast {
        def connection = new URL("https://play.google.com/store/apps").openConnection()
        int response = connection.responseCode
        if (response != 200)
            throw new GradleScriptException("Error, can't check internet connection", null)
        println "Internet is available"
    }
}


static String devId(String id) {
    return "https://play.google.com/store/apps/developer?id=$id"
}

static String cpl(String id) {
    return "https://play.google.com/store/apps/collection/cluster?clp=$id"
}

static String search(String query) {
    return "https://play.google.com/store/search?c=apps&q=$query"
}

import com.brunodles.alchemist.Alchemist
import com.brunodles.alchemist.collectors.AttrCollector
import com.brunodles.alchemist.collectors.TextCollector
import com.brunodles.alchemist.nested.Nested
import com.brunodles.alchemist.selector.Selector
import com.brunodles.alchemist.usevalueof.UseValueOf
import com.google.api.core.ApiFuture
import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import com.google.firebase.database.DatabaseReference
import com.google.firebase.database.FirebaseDatabase
import io.reactivex.Observable
import io.reactivex.schedulers.Schedulers

import java.text.SimpleDateFormat
import java.util.regex.Pattern

@SuppressWarnings("GroovyUnusedDeclaration")
class RatingFetcher {

    static final idPattern = Pattern.compile(/\?id=(.*?)(?:&|$)/)
    private static final String ENV_ROOT_REFERENCE = "FIREBASE_ROOT_REFERENCE"
    private static final String RATINGS_REFERENCE = "ratings"

    private final String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date())
    private final Set<String> done = new HashSet<>()
    private final DatabaseReference ratings
    private final Alchemist alchemist
    private final String[][] developers

    RatingFetcher(String[][] developers, ClassLoader classLoader) {
        this.developers = developers
        this.ratings = buildRatingsReference()
        alchemist = new Alchemist.Builder()
                .classLoader(classLoader)
                .build()
    }

    static DatabaseReference buildRatingsReference() {
        InputStream serviceAccount = new FileInputStream("google.json")
        FirebaseOptions options = new FirebaseOptions.Builder()
                .setCredentials(GoogleCredentials.fromStream(serviceAccount))
                .setDatabaseUrl("https://brunodles-apprating.firebaseio.com/")
                .build()

        def firebase = FirebaseApp.initializeApp(options, "Admin-" +
                String.valueOf(new Random().nextLong()))
        def reference = FirebaseDatabase.getInstance(firebase)
        if (System.getenv().containsKey(ENV_ROOT_REFERENCE))
            return reference.getReference(System.getenv(ENV_ROOT_REFERENCE) + RATINGS_REFERENCE)
        return reference.getReference(RATINGS_REFERENCE)
    }

    Observable<ApiFuture<Void>> appsMap() {
        return Observable.fromArray(developers)
                .subscribeOn(Schedulers.computation())
                .doOnNext { d -> println "Developer: ${d[0]}" }
                .map { developer -> Arrays.copyOfRange(developer, 1, developer.length) }
                .flatMap(Observable.&fromArray)
                .flatMap(this.&developerApps)
                .doOnNext { println "Prepare to send ${it.title()}" }
                .map(this.&mapToMap)
                .map { m -> ratings.child("${date}/${m.appId}".replaceAll(/[.#$\[\]]/, "-")).setValueAsync(m) }
    }

    private Observable<App> developerApps(String url) {
        return Observable.just(url)
                .map { it -> alchemist.parseUrl(it, Developer.class) }
                .flatMap { Observable.fromIterable(it.apps()) }
                .filter { App app -> !done.contains(app.detailsUrl()) }
                .doOnNext { m -> done.add(m.detailsUrl()) }
                .subscribeOn(Schedulers.newThread())
    }

    private Map<String, Object> mapToMap(App app) {
        def map = new HashMap<String, Object>()
//        def appRef = ratings.getReference("${date}/${empresa[0]}/${app.title()}")
        String appDetailsUrl = "https://play.google.com" + app.detailsUrl()

        map.put("name", app.title())
        map.put("coverImageUrl", "https" + app.converImage())
        map.put("url", appDetailsUrl)

        def matcher = idPattern.matcher(appDetailsUrl)
        if (!matcher.find())
            throw new RuntimeException("App id not found on \"${appDetailsUrl}\"")
        def group = matcher.group(1)
        if (group == null || group.isEmpty())
            throw new RuntimeException("App id not found on \"${appDetailsUrl}\"")
        map.put("appId", group)

        try {
            AppDetails appDetails = alchemist.parseUrl(appDetailsUrl, AppDetails.class)

            map.put("ratting", appDetails.rating())
            map.put("name", appDetails.name())
        } catch (Exception e) {
            new Exception("Failed to get details for \"${app.title()}\" using \"${appDetailsUrl}\".", e)
                    .printStackTrace()
        }
        return map
    }


}

interface Developer {
    @Selector(".card-content")
    @Nested
    ArrayList<App> apps()
}

interface App {
    @Selector(".cover-image")
    @AttrCollector("data-cover-large")
    String converImage();

    @Selector(".title")
    @AttrCollector("title")
    String title();

    @Selector(".card-click-target")
    @AttrCollector("href")
    String detailsUrl();
}

interface AppDetails {
    @Selector("[itemprop=\"name\"] span")
    @TextCollector
    String name()

    @Selector("meta[itemprop=\"ratingValue\"]")
    @AttrCollector("content")
    @UseValueOf
    Float rating()
}
